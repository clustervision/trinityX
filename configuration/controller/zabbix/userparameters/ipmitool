#!/usr/bin/python

import argparse
import json
import subprocess
import os
import sys
import time
import tempfile
import fcntl
import logging

__author__ = 'Vladimir Krumshtein <vladimir.krumstein@clustervision.com>'
__date__ = 'Oct 2016'
__version__ = '1.0.0'

DEBUG = False

class IPMITOOL(object):

    EXECUTABLE = '/usr/bin/ipmitool'
    CACHEFILE = '/tmp/ipmitool.cache'
    CACHE_TIME = 30 # seconds

    CUR_TIME = int(time.time())
    CMD = [EXECUTABLE, 'sensor']

    @classmethod
    def execute_cmd(cls):
        proc = subprocess.Popen(cls.CMD, stdout=subprocess.PIPE, close_fds=True)
        if proc.returncode:
            sys.exit(1)
        return proc.communicate()[0].split('\n')[:]

    @classmethod
    def write_to_cache(cls):
        """
        Execute command and write output to cache-file
        """
        lock_fd = open(cls.CACHEFILE, 'r')
        logging.debug("locking")
        fcntl.flock(lock_fd,fcntl.LOCK_EX)
        logging.debug("locked")
        if DEBUG:
            time.sleep(10)
        fdi, tmpfpath = tempfile.mkstemp(prefix = 'ipmitool.')
        fd = os.fdopen(fdi, 'a')
        ret = cls.execute_cmd()
        fd.write(str(cls.CUR_TIME) + '\n')
        fd.write('\n'.join(ret))
        fd.close()
        lock_fd.close()
        logging.debug("lock file closed")
        os.rename(tmpfpath, cls.CACHEFILE)
        return ret

    @classmethod
    def get_data(cls):
        '''
        Cache output to cls.CACHEFILE in order to reduce load to ipmitool and arrays
        '''
        if not os.path.exists(cls.CACHEFILE):
            return cls.write_to_cache()
        fd = open(cls.CACHEFILE, 'r')
        cache_ts = fd.readline().strip()
        if cache_ts and int(cache_ts) + cls.CACHE_TIME > cls.CUR_TIME:
            ret = [l for l in fd.readlines() if len(l) > 0]
            fd.close()
            return ret
        fd.close()
        return cls.write_to_cache()


    if not os.path.exists(EXECUTABLE):
        print "No executable found '%s'. Please install ipmitool " % EXECUTABLE
        sys.exit(1)
    #TODO: handle multiple sensors
    @classmethod
    def discovery_sensors(cls, args):
        data = []
        for line in cls.get_data():
            tmp_arr = [s.strip() for s in line.split('| ') if s.strip()]
            if len(tmp_arr) < 3:
                continue
            if tmp_arr[2] in ( "RPM", "degrees C", "Watts"):
                data.append({'{#SENSOR_NAME}':tmp_arr[0]})
        return json.dumps({'data': data}, separators=(',', ':'))

    @classmethod
    def getinfo(cls, args, parm):
        sensor = args.sensor
        for line in cls.get_data():
            tmp_arr = [s.strip() for s in line.split('| ') if s.strip()]
            if tmp_arr[0].strip(" ") == sensor:
                return tmp_arr[parm]
        return "NA"

    @classmethod
    def value(cls, args):
        return cls.getinfo(args,1)

    @classmethod
    def unit(cls, args):
        return cls.getinfo(args,2)

    @classmethod
    def low_crit(cls, args):
        return cls.getinfo(args,6)

    @classmethod
    def up_crit(cls, args):
        return cls.getinfo(args,7)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true')

    subparsers = parser.add_subparsers()

    subparser_discovery = subparsers.add_parser('discovery')
    subparser_discovery.set_defaults(func=IPMITOOL.discovery_sensors)

    subparser_powerstate = subparsers.add_parser('value')
    subparser_powerstate.set_defaults(func=IPMITOOL.value)
    subparser_powerstate.add_argument('sensor')

    subparser_powerstate = subparsers.add_parser('unit')
    subparser_powerstate.set_defaults(func=IPMITOOL.unit)
    subparser_powerstate.add_argument('sensor')

    subparser_powerstate = subparsers.add_parser('up_crit')
    subparser_powerstate.set_defaults(func=IPMITOOL.up_crit)
    subparser_powerstate.add_argument('sensor')

    subparser_powerstate = subparsers.add_parser('low_crit')
    subparser_powerstate.set_defaults(func=IPMITOOL.low_crit)
    subparser_powerstate.add_argument('sensor')


    return parser.parse_known_args()[0]

def main():
    args = parse_args()
    try:
        if args.debug:
            global DEBUG 
            DEBUG = True
            logging.basicConfig(format='%(process)d %(lineno)d %(message)s',stream=sys.stderr, level=logging.DEBUG)
        print(args.func(args)) 
    except Exception as e:
        if args.debug:
            raise e
        print(e)


if __name__ == '__main__':
    main()

# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
