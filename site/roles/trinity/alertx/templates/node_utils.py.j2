__version__     = '15.2.0.0'

import subprocess
import re
from typing import List, Tuple
from logger import Logger
import config  

log = Logger.get_logger("TRIX-DRAINER: node_utils")


class NodeUtils:
    """
    Utility class for interacting with Slurm nodes.
    """

    @staticmethod
    def get_node_states() -> Tuple[List[str], List[str], List[str]]:
        try:
            # 1) One line per node => robust parsing
            output = subprocess.check_output(['scontrol', '-o', 'show', 'nodes'], text=True, timeout=10)

            all_nodes = []
            not_drained_nodes = []
            drainer_drained_nodes = []

            # 2) One record per line now
            node_lines = output.strip().splitlines()

            for line in node_lines:
                # 3) Tighter patterns; stop Reason at next key or EOL
                name_match  = re.search(r"\bNodeName=(\S+)", line)
                state_match = re.search(r"\bState=([^\s]+)", line)
                reason_match = re.search(r"\bReason=(.*?)(?=\s+\w+=|$)", line)

                if name_match and state_match:
                    name = name_match.group(1)
                    state = state_match.group(1)
                    all_nodes.append(name)

                    # Normalize reason (handle empty, (null), none)
                    reason = reason_match.group(1).strip() if reason_match else ""
                    if reason.lower() in {"", "(null)", "none"}:
                        reason = ""

                    # Slurm states can be 'IDLE+DRAIN', 'DOWN+DRAINED', etc.
                    if "DRAIN" in state:
                        if reason and config.MARKER in reason:
                            drainer_drained_nodes.append(name)
                    else:
                        not_drained_nodes.append(name)

            log.debug(f"Found {len(all_nodes)} total nodes, {len(not_drained_nodes)} not drained, "
                    f"{len(drainer_drained_nodes)} drainer-drained nodes.")
            return all_nodes, not_drained_nodes, drainer_drained_nodes

        except subprocess.CalledProcessError as e:
            log.error(f"Failed to run 'scontrol show nodes': {e}")
            return [], [], []
        except subprocess.TimeoutExpired as e:
            log.error(f"Timeout exception: {e}")
            return [], [], []
        except Exception as e:
            log.error(f"Exception occured: {e}")
            return [], [], []

    @staticmethod
    def drain_node(node_name: str, reason: str) -> None:
        """
        Drains a node with a specified reason.
        """
        try:
            full_reason = f"{config.MARKER}{reason}"
            subprocess.check_call(['scontrol', 'update', f'NodeName={node_name}', 'State=DRAIN', f'Reason={full_reason}'], timeout=10)
            log.info(f"Node {node_name} drained with reason: {full_reason}")
        except subprocess.CalledProcessError as e:
            log.error(f"Failed to drain node {node_name}: {e}")
        except subprocess.TimeoutExpired as e:
            log.error(f"Timeout exception: {e}")
        except Exception as e:
            log.error(f"Exception occured: {e}")

    @staticmethod
    def undrain_node(node_name: str) -> None:
        """
        Undrains a node (sets it back to RESUME state).
        """
        try:
            subprocess.check_call(['scontrol', 'update', f'NodeName={node_name}', 'State=RESUME'], timeout=10)
            log.info(f"Node {node_name} resumed successfully.")
        except subprocess.CalledProcessError as e:
            log.error(f"Failed to undrain node {node_name}: {e}")
        except subprocess.TimeoutExpired as e:
            log.error(f"Timeout exception: {e}")
        except Exception as e:
            log.error(f"Exception occured: {e}")
            
    @staticmethod
    def update_drain_reason(node_name: str, new_reason: str) -> None:
        """
        Unconditionally updates the drain reason for a node.
        """
        try:
            full_reason = f"{config.MARKER}{new_reason}"
            subprocess.check_call(['scontrol', 'update', f'NodeName={node_name}', f'Reason={full_reason}'], timeout=10)
            log.info(f"Set drain reason for {node_name}: '{new_reason}'")
        except subprocess.CalledProcessError as e:
            log.error(f"Failed to update reason for node {node_name}: {e}")
        except subprocess.TimeoutExpired as e:
            log.error(f"Timeout exception: {e}")
        except Exception as e:
            log.error(f"Exception occured: {e}")

